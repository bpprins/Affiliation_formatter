#!/usr/bin/env python

'''
This script was written to create a formatted list of author affiliation list
for publications with too many authors.

Version: 1.1 Last modified: 2016.12.27

Change log:
    - Advanced error checking and more informative error messages.
    - Column headers now case insensitve
    - Adjusted for python 3.5

For comments and questions: ds26@sanger.ac.uk

Required fields of the input xlsx file:
"First Name",
"Middle Name" (Only initials, without spaces),
"Last Name"

Affiliation fields:
"Institute/Department/University",
"City/State",
"Post/Zip code",
"Country"

The affiliation fields can be repeated as many times as necessary. Other fields
in the xlsx table will not be considered. As of v.1.1 field names are case insensitive!

Output formats:
Author names: [First name] [Middle name initials]. [Last name]^[affiliation_number]
Affiliation list: [affiliation_number]. [Institute/Department/University], [City/State] [Post/Zip Code], [Country]

Requirements: pandas v1.6 or above.
'''

# importing libraries:
from __future__ import print_function
import argparse
import re
import os.path
import sys

# Testing if the python interpreter is at least 3.0
if sys.version_info[0] != 3:
    print("[Error] Python version is too old. Python 3 is required. Exiting")
    quit()

parser = argparse.ArgumentParser()
input_options = parser.add_argument_group('Options')
input_options.add_argument("-i", "--input", help="Input xlsx file.", required=True)
input_options.add_argument("-o", "--output", help="Output html file.", required=False)

# Extracting command line parameters:
args = parser.parse_args()
inputFile = args.input
outputFile = ''

if args.output:
    outputFile = args.output
else:
    # Output file was not given, generated by the input filename:
    try:
        filename = re.search("/+(.+)\.xls", inputFile)
        outputFile = filename.groups()[0] + ".html"
    except:
        filename = re.search("(.+)\.xls", inputFile)
        outputFile = filename.groups()[0] + ".html"

# Print status update:
print("[Info] Input file: %s\n[Info] Output file: %s" %(inputFile, outputFile))

# Check if input file is exists:
if not os.path.isfile(inputFile):
    sys.exit("[Error] Input file (%s) does not exist.\n" % (inputFile))

# pandas is the only package that has to be loaded:
try:
    import pandas as pd
except:
    print("[Error] pandas package (version 0.16 or above) is required! Exiting.")
    quit();

# checking pandas version:
try:
    int(pd.__version__.split(".")[1])
    if int(pd.__version__.split(".")[1]) < 16:
        print("[Error] pandas version should be at least 0.16! Exiting.")
        quit()
except:
    print("[Error] Version testing of the pandas package was failed. Exiting.")
    quit()

# Reading input xlsx file as a pandas dataframe:
try:
    df = pd.read_excel(inputFile)
except:
    sys.exit("[Error] Excel table could not be loaded! Check format.")

# Modifying column headers:
df.columns = [x.lower() for x in df.columns] # Set all column names to lowercase.
df.columns = [x.replace(" ", "_") for x in df.columns] # Replacing spaces with underscores.

# Checking fields of the dataframe. If any of the required fields are missing, the script will terminate:
fields = df.columns.tolist()
if ((not 'first_name' in  fields) or
        (not 'middle_name' in  fields) or
        (not 'last_name' in  fields)):
    sys.exit("[Error] Name fields are missing! 'first name', 'middle name' and 'last name' are required fields of the xlsx file!\n")

if ((not 'institute/department/university' in  fields) or
        (not 'city/state' in  fields) or
        (not 'post/zip_code' in  fields) or
        (not 'country' in  fields)):
    sys.exit("[Error] Affiliation fields are missing! 'Institute/Department/University', 'Post/Zip code', 'City/State' and 'Country' are required fields of the xlsx file!\n")

# Get maximum number of affiliations (based on field counts):
suffixes = ['']
for field in df.columns.tolist():
    try:
        match = re.search("country(.+)", field)
        suffixes.append(match.groups()[0])
    except:
        continue
print("[Info] Maximum number of affiliations: %s" %(len(suffixes)))
print("[INfo] Number of authors in the list: %s" %(len(df)))

# At this point I have to delete all lines where none of the name fields are filled:
df = df.dropna(how='all', subset=["first_name", "middle_name", "last_name"]).reindex()

def get_full_name(row):
    '''
    A small function to generate full name of the authors.
    All first, middle and last names have to stripped to make sure there are not extra spaces added.

    <First name> <Middle name initials>. <Last name>

    '''

    full_name = ""
    try:
        first = row["first_name"].strip()
        middle = row["middle_name"]
        last = row["last_name"].strip()

        if pd.isnull(middle):
            full_name = first+" "+last
        else:
            full_name = first.strip()
            for initial in middle.strip():
                full_name += " " +initial+"."
            full_name += " " +last
    except:
        try:
            full_name = row["first_name"].strip()
        except:
            full_name = row["last_name"].strip()
    return full_name

def get_affiliation_lists(row, suffixes):
    '''
    A small function to generate a list of affiliations.

    '<Department/Institute>, <Town/city> <Post code/Zip code>, <Country>'
    '''
    affiliation_list = []

    for suffix in suffixes:

        affiliation = ""

        inst = row['institute/department/university'+suffix]
        city = row['city/state'+suffix]
        postcode = row['post/zip_code'+suffix]
        country = row['country'+suffix]

        if not pd.isnull(inst):
            affiliation += inst.strip()
            if not pd.isnull(city):
                affiliation += ", " + city.strip()
            if not pd.isnull(postcode):
                affiliation += " " + str(postcode).strip()
            if not pd.isnull(country):
                affiliation += ", " + country.strip()

        if len(affiliation) > 0:
            affiliation_list.append(affiliation)

    return affiliation_list


## Generate formatted full-names:
df['full_name'] = df.apply(get_full_name, axis=1)

# Generate a list of formatted affiliations:
df['affiliation_total'] = df.apply(get_affiliation_lists, axis=1, args=([suffixes]))

# Combining authors and affiliations together:
names_numbers = []
affiliation_list = {}
affiliation_index = 0

for row in df.iterrows():
    numbers = []

    # checking if the given affiliation is already given
    for affiliation in row[1]["affiliation_total"]:
        try:
            numbers.append(affiliation_list[affiliation])
        except:
            affiliation_index += 1
            affiliation_list[affiliation] = affiliation_index
            numbers.append(affiliation_list[affiliation])
    names_numbers.append([row[1]['full_name'], numbers])

# Final datastructures:
names_numbers
affiliation_list

# Now we have to print out the affiliation list sorted for the dictionary value:
affiliation_list_sorted = sorted(affiliation_list, key=affiliation_list.get)

print("[Info] Formatting output... ", end='')

# Now saving what we have:
html = '<!DOCTYPE html>\n<html>\n<head><meta charset="UTF-8"></head>\n<body>\n<div></div>\n\n<div style="font-size: 16px; margin-left: 10px">'

# Looping through all authors:
for row in names_numbers:
    author = row[0]
    affiliation = row[1]
    html += author

    if len(affiliation) > 0:
        aff_string = ",".join(str(x) for x in sorted(affiliation))
        html += '<sup>%s</sup>, \n' % aff_string
    else:
        html += ', '

html += '</div>\n\n<div></div><div></div><div style="font-size: 12px; margin-left: 20px">\n\n<ol>'
# Now looping through all the affiliations and save them:
for index, affiliation in enumerate(affiliation_list_sorted):
    html += '\t<li>%s</li>\n' %(affiliation.encode('ascii', 'xmlcharrefreplace').decode("ASCII"))

html += '</ol>\n<br>\n</body>\n</html>'

# Saving html data into file:
f = open(outputFile, 'w')
f.write(html)
f.close()

print(" done.")
